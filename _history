{"entries":[{"timestamp":1745870966910,"editorVersion":"2.0.53","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":131,"diffs":[[1,"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":1,"diffs":[[1," "]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":179,"length1":64,"diffs":[[1,"        \"assets.json\"\n"]]},{"start1":208,"length1":31,"diffs":[[1,"    \"additionalFilePaths\": []\n"]]}]},{"type":"added","filename":"custom.ts","value":"namespace scene {\n    const PATH_FOLLOW_KEY = \"A_STAR_PATH_FOLLOW\";\n    const PATH_COMPLETION_KEY = \"A_STAR_PATH_COMPLETION_HANDLER\";\n\n    class PathFollowingSprite {\n        public index: number;\n        public onEndHandler: () => void;\n\n        constructor(\n            public sprite: Sprite,\n            public path: tiles.Location[],\n            public speed: number\n        ) {\n            this.index = 0;\n        }\n    }\n\n    class PathCompletionEvent {\n        constructor(\n            public kind: number,\n            public handler: (sprite: Sprite, location: tiles.Location) => void\n        ) { }\n    }\n\n    function init() {\n        if (!game.currentScene().data[PATH_FOLLOW_KEY]) {\n            game.currentScene().data[PATH_FOLLOW_KEY] = [] as PathFollowingSprite[];\n            game.currentScene().data[PATH_COMPLETION_KEY] = [] as PathCompletionEvent[];\n\n            game.onUpdate(function () {\n                const store = getPathFollowingSprites();\n                const handlers = getPathCompletionEvents();\n\n                for (let i = store.length - 1; i >= 0; i--)\n                // note we enumerate from the end so we can safely remove and push without changing\n                // the worklist\n                {\n                    const pfs = store[i]\n                    const { sprite, index, path, speed } = pfs;\n                    const target: tiles.Location = path[index];\n\n                    const { x, y, vx, vy } = sprite;\n\n                    const pastTargetHorizontally = !vx || (vx < 0 && x <= target.x) || (vx > 0 && x >= target.x);\n                    const pastTargetVertically = !vy || (vy < 0 && y <= target.y) || (vy > 0 && y >= target.y);\n\n                    if (pastTargetHorizontally && pastTargetVertically) {\n                        // target next index\n                        pfs.index++;\n                        const newTarget = path[pfs.index];\n                        if (!newTarget) {\n                            sprite.setVelocity(0, 0);\n                            target.place(sprite);\n                            store.removeAt(i);\n                            // explicit endCb overrides kind cb\n                            if (pfs.onEndHandler) {\n                                pfs.onEndHandler();\n                            } else {\n                                handlers.forEach(completionHandler => {\n                                    if (completionHandler.kind === sprite.kind()) {\n                                        completionHandler.handler(sprite, path[pfs.index - 1]);\n                                    }\n                                });\n                            }\n                        } else {\n                            target.place(sprite);\n                            setVelocityTowards(sprite, newTarget, speed);\n                        }\n                    }\n                }\n            });\n        }\n    }\n\n    function setVelocityTowards(sprite: Sprite, target: tiles.Location, speed: number) {\n        const dx = target.x - sprite.x;\n        const dy = target.y - sprite.y;\n        const dist = Math.sqrt(dx * dx + dy * dy) || 1;\n        sprite.vx = (dx / dist) * speed;\n        sprite.vy = (dy / dist) * speed;\n    }\n\n    // TODO: probably should have logic to bail when a tile that wasn't a wall\n    //      is set to be a wall. Or just use velocity, and let enemy run into wall\n\n    /**\n     * Give a sprite a path to follow\n     * @param sprite sprite to give a path to\n     * @param path path to follow\n     * @param speed speed at which to follow path eg: 50\n     */\n    //% block=\"sprite $sprite follow path $path || speed %speed\"\n    //% sprite.shadow=\"variables_get\"\n    //% sprite.defl=\"mySprite\"\n    //% path.shadow=\"variables_get\"\n    //% path.defl=\"locationTiles\"\n    //% help=github:arcade-tilemap-a-star/docs/follow-path\n    //% group=\"Path Following\" weight=9\n    export function followPath(sprite: Sprite, path: tiles.Location[], speed: number = 50) {\n        if (!sprite)\n            return;\n        if (!path || !path.length || !speed) {\n            const pathFollowingSprites = getPathFollowingSprites();\n            if (pathFollowingSprites) {\n                for (let i = pathFollowingSprites.length - 1; i >= 0; i--) {\n                    const pfs = pathFollowingSprites[i];\n                    if (pfs.sprite === sprite) {\n                        sprite.vx = 0;\n                        sprite.vy = 0;\n                        pathFollowingSprites.removeAt(i);\n                    }\n                }\n            }\n            return;\n        }\n\n        const tm = game.currentScene().tileMap;\n        if (!tm)\n            return;\n\n        // are we in a wall?\n        if (tm.isOnWall(sprite)) {\n            // if so, find the closest path tile by distance and teleport there\n            let nearestTile = path[0]\n            let minDistSquared = 999999;\n            for (let p of path) {\n                const distSqrd = (p.x - sprite.x) ** 2 + (p.y - sprite.y) ** 2\n                if (distSqrd < minDistSquared) {\n                    nearestTile = p\n                    minDistSquared = distSqrd\n                }\n            }\n            nearestTile.place(sprite);\n            const remainingPath = getRemainingPath(sprite, path);\n            _followPath(sprite, remainingPath, speed);\n            return\n        }\n\n        // if we're on the path already, just follow the subset of the remaining path\n        const remainingPath = getRemainingPath(sprite, path);\n        if (remainingPath) {\n            _followPath(sprite, remainingPath, speed);\n            return;\n        }\n\n        // otherwise, path with a-star (no heuristic and no onTileOf) to the path\n        const currentLocation = locationOfSprite(sprite)\n        const pathToNearest = generalAStar(tm, currentLocation, null, () => 0, tile => {\n            for (let pathTile of path) {\n                if (tile.col === pathTile.col && tile.row === pathTile.row) {\n                    return true;\n                }\n            }\n            return false;\n        });\n\n        _followPath(sprite, pathToNearest, speed, () => {\n            // then follow the remaining of the path\n            const remainingPath = getRemainingPath(sprite, path);\n            _followPath(sprite, remainingPath, speed);\n        })\n    }\n\n    /**\n     * Returns true if the sprite is currently following a path,\n     * and false otherwise\n     * @param sprite sprite to check if following path\n     */\n    //% block=\"sprite $sprite is following a path\"\n    //% sprite.shadow=\"variables_get\"\n    //% sprite.defl=\"mySprite\"\n    //% help=github:arcade-tilemap-a-star/docs/sprite-is-following-path\n    //% group=\"Path Following\" weight=8\n    export function spriteIsFollowingPath(sprite: Sprite): boolean {\n        init();\n        return getPathFollowingSprites().some(pfs => pfs.sprite === sprite);\n    }\n\n    /**\n     * Returns an approximation between 0 and 100 of how much of the\n     * percentage of the path that the given sprite is following has completed.\n     * If the sprite is not currently following a path,\n     * this returns 100 (as the sprite has trivially completed the empty path).\n     */\n    //% block=\"percent sprite $sprite path completion\"\n    //% sprite.shadow=\"variables_get\"\n    //% sprite.defl=\"mySprite\"\n    //% help=github:arcade-tilemap-a-star/docs/sprite-percent-path-completed\n    //% group=\"Path Following\" weight=7\n    export function spritePercentPathCompleted(sprite: Sprite): number {\n        init();\n        const pfs = getPathFollowingSprites().find(pfs => pfs.sprite === sprite);\n        // TODO: is this behavior useful, or should this return 0 or undefined?\n        if (!pfs)\n            return 100;\n        return 100 - (100 * (pfs.path.length - pfs.index) / pfs.path.length);\n    }\n\n    /**\n     * Event handler for when a sprite of the given kind completes a path\n     */\n    //% group=\"Overlaps\"\n    //% weight=100 draggableParameters=\"reporter\"\n    //% block=\"on $sprite of kind $kind completes path at $location\"\n    //% kind.shadow=spritekind\n    //% help=github:arcade-tilemap-a-star/docs/on-path-completion\n    //% group=\"Path Following\" weight=6\n    export function onPathCompletion(\n        kind: number,\n        handler: (sprite: Sprite, location: tiles.Location) => void\n    ) {\n        init();\n        if (kind == null || !handler)\n            return;\n        getPathCompletionEvents().push(\n            new PathCompletionEvent(kind, handler)\n        );\n    }\n\n    export function teleportToAndFollowPath(sprite: Sprite, path: tiles.Location[], speed?: number) {\n        _followPath(sprite, path, speed);\n    }\n\n    export function _followPath(sprite: Sprite, path: tiles.Location[], speed?: number, endCb?: () => void) {\n        if (!sprite)\n            return;\n\n        init();\n        const store = getPathFollowingSprites();\n        const previousEl = store.find(el => el.sprite === sprite);\n\n        const start = path && path[0];\n        if (!start) {\n            if (previousEl) {\n                store.removeElement(previousEl);\n            }\n            return;\n        }\n\n        const pfs = previousEl || new PathFollowingSprite(\n            sprite,\n            path,\n            speed || 50\n        );\n        if (previousEl) {\n            if (speed)\n                previousEl.speed = speed;\n            previousEl.path = path;\n            previousEl.index = 0;\n\n            if (endCb) {\n                previousEl.onEndHandler = endCb;\n            }\n        } else {\n            pfs.onEndHandler = endCb;\n            store.push(pfs);\n        }\n\n        setVelocityTowards(sprite, start, pfs.speed)\n    }\n\n    /**\n     * Returns the index in the path which is closest to the current sprite by direct distance\n     */\n    export function getNearestPathIdx(sprite: Sprite, path: tiles.Location[]): number {\n        let minDistSqrd = 99999\n        let idx = 0;\n        for (let i = 0; i < path.length; i++) {\n            let t = path[i];\n            let distSqrd = (sprite.x - t.x) ** 2 + (sprite.y - t.y) ** 2;\n            if (distSqrd < minDistSqrd) {\n                minDistSqrd = distSqrd;\n                idx = i;\n            }\n        }\n        return idx\n    }\n\n    function getPathFollowingSprites(): PathFollowingSprite[] {\n        return game.currentScene().data[PATH_FOLLOW_KEY] as PathFollowingSprite[];\n    }\n\n    function getPathCompletionEvents(): PathCompletionEvent[] {\n        return game.currentScene().data[PATH_COMPLETION_KEY] as PathCompletionEvent[];\n    }\n\n    function screenCoordinateToTile(value: number) {\n        const tm = game.currentScene().tileMap;\n        if (!tm) return value >> 4;\n        return value >> tm.scale;\n    }\n\n    function locationOfSprite(s: Sprite): tiles.Location {\n        return tiles.getTileLocation(screenCoordinateToTile(s.x), screenCoordinateToTile(s.y));\n    }\n\n    function getRemainingPath(sprite: Sprite, path: tiles.Location[]): tiles.Location[] | null {\n        const currentLocation = locationOfSprite(sprite)\n        for (let i = 0; i < path.length; i++) {\n            const pathTile = path[i];\n            if (currentLocation.x === pathTile.x && currentLocation.y === pathTile.y) {\n                const remainingPath = i === 0 ? path : path.filter((_, j) => j >= i);\n                return remainingPath;\n            }\n        }\n        return null\n    }\n}"},{"type":"added","filename":"a-star.ts","value":"//+array+SimpleLocation sim:7.5%, meowbit:10.5% ms comparing with origin\nnamespace scene {\n    //costs, scaled up by 1000\n    const NEIGHBOR_COST = 1000;\n    const DIAGONAL_COST = 1414;\n    class PrioritizedLocation {\n        constructor(\n            public loc: SimpleLocation,\n            public cost: number,\n            public totalCost: number  //cost+heuristic\n        ) { }\n    }\n\n    class LocationNode {\n        public visited: boolean;\n\n        constructor(\n            public l: SimpleLocation,\n            public parent: LocationNode,\n            public lastCost: number\n        ) {\n            this.visited = false;\n        }\n    }\n\n    class SimpleLocation {\n        constructor(public col: number, public row: number) { }\n    }\n\n    /**\n     * Find the shortest path between start and end that does not contain walls and optionally limited to a pathable tile.\n     */\n    //% block=\"path from $start to $end||on tiles of $onTilesOf\"\n    //% start.shadow=mapgettile\n    //% end.shadow=mapgettile\n    //% onTilesOf.shadow=tileset_tile_picker\n    //% onTilesOf.decompileIndirectFixedInstances=true\n    //% help=github:arcade-tilemap-a-star/docs/a-star\n    //% group=\"Path Following\" weight=10\n    export function aStar(start: tiles.Location, end: tiles.Location, onTilesOf: Image = null) {\n        const tm = game.currentScene().tileMap;\n        if (!tm || !start || !end)\n            return undefined;\n\n        const end1 = new SimpleLocation(end.col, end.row)\n        const start1 = new SimpleLocation(start.col, start.row)\n        if (!isWalkable(end1, onTilesOf, tm))\n            return undefined;\n\n        return generalAStar(tm, start1, onTilesOf,\n            t => tileLocationHeuristic(t, end1),\n            l => l.col == end1.col && l.row == end1.row);\n    }\n\n    export function aStarToAnyOfType(start: tiles.Location, tile: Image, onTilesOf: Image) {\n        const tm = game.currentScene().tileMap;\n        if (!tm || !start)\n            return undefined;\n        const start1 = new SimpleLocation(start.col, start.row)\n        const endIndex = tm.getImageType(tile);\n        const potentialEndPoints = tm.getTilesByType(endIndex);\n\n        if (!potentialEndPoints || potentialEndPoints.length === 0)\n            return undefined;\n\n        return generalAStar(tm, start1, onTilesOf,\n            t => 0,\n            l => {\n                return endIndex === tm.getTileIndex((l as any)._col, (l as any)._row)\n            });\n    }\n\n    export function generalAStar(tm: tiles.TileMap, start: SimpleLocation, onTilesOf: Image,\n        heuristic: (tile: SimpleLocation) => number,\n        isEnd: (tile: SimpleLocation) => boolean): tiles.Location[] {\n\n        if (!isWalkable(start, onTilesOf, tm)) {\n            return undefined;\n        }\n\n        const consideredTiles: Array<PrioritizedLocation> = []\n        const encountedLocations: LocationNode[][] = [[]];\n\n        function updateOrFillLocation(l: SimpleLocation, parent: LocationNode, cost: number) {\n            const row = l.row;\n            const col = l.col;\n\n\n            const colData = (encountedLocations[col] || (encountedLocations[col] = []));\n            const lData = colData[row];\n\n            if (!lData) {\n                colData[row] = new LocationNode(\n                    l,\n                    parent,\n                    cost\n                );\n            } else if (lData.lastCost > cost) {\n                lData.lastCost = cost;\n                lData.parent = parent;\n            } else {\n                return;\n            }\n\n            const newConsideredTile = new PrioritizedLocation(\n                l,\n                cost,\n                cost + heuristic(l)\n            )\n\n\n            if (consideredTiles.length == 0) {\n                consideredTiles.push(newConsideredTile)\n                return\n            }\n            let i = consideredTiles.length - 1\n            for (; i >= 0; i--) {  // seek & insert from end, last N are more possible hit\n                if (newConsideredTile.totalCost < consideredTiles[i].totalCost) {\n                    consideredTiles.insertAt(i + 1, newConsideredTile)\n                    return;\n                }\n            }\n            if (i < 0)\n                consideredTiles.insertAt(0, newConsideredTile)\n        }\n\n        updateOrFillLocation(start, null, 0);\n\n        let end: SimpleLocation = null;\n        while (consideredTiles.length !== 0) {\n\n            const currLocation = consideredTiles.pop();\n\n            if (isEnd(currLocation.loc)) {\n                end = currLocation.loc;\n                break;\n            }\n\n            const row = currLocation.loc.row;\n            const col = currLocation.loc.col;\n\n\n            const dataForCurrLocation = encountedLocations[col][row];\n\n            if (dataForCurrLocation && dataForCurrLocation.visited) {\n                continue;\n            }\n            dataForCurrLocation.visited = true;\n\n            const left = new SimpleLocation(col - 1, row);\n            const right = new SimpleLocation(col + 1, row);\n            const top = new SimpleLocation(col, row - 1);\n            const bottom = new SimpleLocation(col, row + 1);\n\n            let leftIsWall = false\n            let rightIsWall = false\n            let topIsWall = false\n            let bottomIsWall = false\n\n            if (onTilesOf) {\n                leftIsWall = !isWalkable(left, onTilesOf, tm);\n                rightIsWall = !isWalkable(right, onTilesOf, tm);\n                topIsWall = !isWalkable(top, onTilesOf, tm);\n                bottomIsWall = !isWalkable(bottom, onTilesOf, tm);\n            } else {\n                leftIsWall = tm.isObstacle(left.col, left.row);\n                rightIsWall = tm.isObstacle(right.col, right.row);\n                topIsWall = tm.isObstacle(top.col, top.row);\n                bottomIsWall = tm.isObstacle(bottom.col, bottom.row);\n            }\n\n\n            const neighborCost = currLocation.cost + NEIGHBOR_COST;\n            const cornerCost = currLocation.cost + DIAGONAL_COST;\n\n            if (!leftIsWall) {\n                updateOrFillLocation(left, dataForCurrLocation, neighborCost);\n                if (!topIsWall) {\n                    const topLeft = new SimpleLocation(col - 1, row - 1);\n                    if (!tm.isObstacle(topLeft.col, topLeft.row)) updateOrFillLocation(topLeft, dataForCurrLocation, cornerCost);\n                }\n                if (!bottomIsWall) {\n                    const bottomLeft = new SimpleLocation(col - 1, row + 1);\n                    if (!tm.isObstacle(bottomLeft.col, bottomLeft.row)) updateOrFillLocation(bottomLeft, dataForCurrLocation, cornerCost);\n                }\n            }\n\n            if (!rightIsWall) {\n                updateOrFillLocation(right, dataForCurrLocation, neighborCost);\n                if (!topIsWall) {\n                    const topRight = new SimpleLocation(col + 1, row - 1);\n                    if (!tm.isObstacle(topRight.col, topRight.row)) updateOrFillLocation(topRight, dataForCurrLocation, cornerCost);\n                }\n                if (!bottomIsWall) {\n                    const bottomRight = new SimpleLocation(col + 1, row + 1);\n                    if (!tm.isObstacle(bottomRight.col, bottomRight.row)) updateOrFillLocation(bottomRight, dataForCurrLocation, cornerCost);\n                }\n            }\n\n            if (!topIsWall) updateOrFillLocation(top, dataForCurrLocation, neighborCost);\n            if (!bottomIsWall) updateOrFillLocation(bottom, dataForCurrLocation, neighborCost);\n        }\n\n        const endCol = end && encountedLocations[end.col];\n        const endDataNode = endCol && endCol[end.row];\n\n        // no path found\n        if (!end || !endDataNode)\n            return undefined;\n\n        let curr = endDataNode;\n\n        // otherwise trace back path to end\n        const output: tiles.Location[] = [];\n\n        while (curr) {\n            output.unshift(new tiles.Location(curr.l.col, curr.l.row, tm));\n            curr = curr.parent;\n        }\n\n        return output;\n    }\n\n    function tileLocationHeuristic(tile: SimpleLocation, target: SimpleLocation) {\n        const xDist = Math.abs(target.col - tile.col)\n        const yDist = Math.abs(target.row - tile.row)\n        return Math.max(xDist, yDist) * NEIGHBOR_COST + Math.min(xDist, yDist) *\n            (DIAGONAL_COST - NEIGHBOR_COST)\n    }\n\n    function isWalkable(loc: SimpleLocation, onTilesOf: Image, tm: tiles.TileMap): boolean {\n        if (tm.isObstacle(loc.col, loc.row)) return false;\n        if (!onTilesOf) return true;\n        const img = tm.getTileImage(tm.getTileIndex(loc.col, loc.row))\n        return img.equals(onTilesOf);\n    }\n}"}]},{"timestamp":1745871572273,"editorVersion":"2.0.53","changes":[{"type":"edited","filename":"custom.ts","patch":[{"start1":0,"length1":1,"diffs":[[1,""]]}]}]},{"timestamp":1745871606245,"editorVersion":"2.0.53","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":389,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":250,"length1":44,"diffs":[[1,""]]}]},{"type":"edited","filename":"custom.ts","patch":[{"start1":0,"length1":57,"diffs":[[1,"\nnamespace scene {\n"]]},{"start1":7891,"length1":0,"diffs":[[1,"    //% group=\"Overlaps\"\n"]]}]},{"type":"edited","filename":"a-star.ts","patch":[{"start1":73,"length1":57,"diffs":[[1,"namespace scene {\n"]]}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"}]}],"snapshots":[{"timestamp":1745870966909,"editorVersion":"2.0.53","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>","main.ts":" ","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"extension\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}}],"shares":[],"lastSaveTime":1745871987138}